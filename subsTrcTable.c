/*
 * Note: this file originally auto-generated by mib2c using
 *  $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "subsTrcTable.h"

/** Initializes the subsTrcTable module */
void
init_subsTrcTable(void)
{
  /* here we initialize all the tables we're planning on supporting */
    initialize_table_subsTrcTable();
}


/** Initialize the subsTrcTable table by defining its contents and how it's structured */
void
initialize_table_subsTrcTable(void)
{
    const oid subsTrcTable_oid[] = {1,3,6,1,4,1,88888,1};
    const size_t subsTrcTable_oid_len   = OID_LENGTH(subsTrcTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_tdata                   *table_data;
    netsnmp_table_registration_info *table_info;
    netsnmp_cache                   *cache;

    DEBUGMSGTL(("subsTrcTable:init", "initializing table subsTrcTable\n"));

    reg = netsnmp_create_handler_registration(
              "subsTrcTable",     subsTrcTable_handler,
              subsTrcTable_oid, subsTrcTable_oid_len,
              HANDLER_CAN_RWRITE
              );

    table_data = netsnmp_tdata_create_table( "subsTrcTable", 0 );
    if (NULL == table_data) {
        snmp_log(LOG_ERR,"error creating tdata table for subsTrcTable\n");
        return;
    }
    cache = netsnmp_cache_create(SUBSTRCTABLE_TIMEOUT,
                                  subsTrcTable_load, subsTrcTable_free,
                                  subsTrcTable_oid, subsTrcTable_oid_len);
    if (NULL == cache) {
        snmp_log(LOG_ERR,"error creating cache for subsTrcTable\n");
    }
    else
        cache->magic = (void *)table_data;
    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    if (NULL == table_info) {
        snmp_log(LOG_ERR,"error creating table info for subsTrcTable\n");
        return;
    }
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: subsTrcIdType */
                           ASN_OCTET_STR,  /* index: subsTrcIdName */
                           0);

    table_info->min_column = COLUMN_SUBSTRCLEVEL;
    table_info->max_column = COLUMN_SUBSTRCROWSTATUS;
    
    netsnmp_tdata_register( reg, table_data, table_info );
    if (cache) 
        netsnmp_inject_handler_before( reg, netsnmp_cache_handler_GET(cache),
                                       TABLE_TDATA_NAME);

    /* Initialise the contents of the table here */
}

    /* Typical data structure for a row entry */
struct subsTrcTable_entry {
    /* Index values */
    long subsTrcIdType;
    char subsTrcIdName[NNN];
    size_t subsTrcIdName_len;

    /* Column values */
    long subsTrcLevel;
    long old_subsTrcLevel;
    long subsTrcType;
    long old_subsTrcType;
    long subsTrcRowStatus;

    int   valid;
};

/* create a new row in the table */
netsnmp_tdata_row *
subsTrcTable_createEntry(netsnmp_tdata *table_data
                 , long  subsTrcIdType
                 , char* subsTrcIdName
                 , size_t subsTrcIdName_len
                ) {
    struct subsTrcTable_entry *entry;
    netsnmp_tdata_row *row;

    entry = SNMP_MALLOC_TYPEDEF(struct subsTrcTable_entry);
    if (!entry)
        return NULL;

    row = netsnmp_tdata_create_row();
    if (!row) {
        SNMP_FREE(entry);
        return NULL;
    }
    row->data = entry;

    DEBUGMSGT(("subsTrcTable:entry:create", "row 0x%x\n", (uintptr_t)row));
    entry->subsTrcIdType = subsTrcIdType;
    netsnmp_tdata_row_add_index( row, ASN_INTEGER,
                                 &(entry->subsTrcIdType),
                                 sizeof(entry->subsTrcIdType));
    memcpy(entry->subsTrcIdName, subsTrcIdName, subsTrcIdName_len);
    entry->subsTrcIdName_len = subsTrcIdName_len;
    netsnmp_tdata_row_add_index( row, ASN_OCTET_STR,
                                 entry->subsTrcIdName, subsTrcIdName_len);
    if (table_data)
        netsnmp_tdata_add_row( table_data, row );
    return row;
}

/* remove a row from the table */
void
subsTrcTable_removeEntry(netsnmp_tdata     *table_data, 
                 netsnmp_tdata_row *row) {
    struct subsTrcTable_entry *entry;

    if (!row)
        return;    /* Nothing to remove */

    DEBUGMSGT(("subsTrcTable:entry:remove", "row 0x%x\n", (uintptr_t)row));

    entry = (struct subsTrcTable_entry *)row->data;
    SNMP_FREE( entry );   /* XXX - release any other internal resources */

    if (table_data)
        netsnmp_tdata_remove_and_delete_row( table_data, row );
    else
        netsnmp_tdata_delete_row( row );    
}

/* Example cache handling - set up table_data list from a suitable file */
int
subsTrcTable_load( netsnmp_cache *cache, void *vmagic ) {
    netsnmp_tdata     *table = (netsnmp_tdata *)vmagic;
    netsnmp_tdata_row *row;
    struct subsTrcTable_entry *this;
    FILE *fp;
    char buf[STRMAX];
    long  subsTrcIdType;
    char* subsTrcIdName;
    size_t subsTrcIdName_len;

    /* The basic load routine template assumes that the data to
       be reported is held in a file - with one row of the file
       for each row of the table.
          If your data is available via a different API, you
       should amend this initial block (and the control of the
       'while' loop) accordingly.
          'XXX' marks places where the template is incomplete and
       code will definitely need to be added. */

    fp = fopen( "/data/for/subsTrcTable", "r" );
    if ( !fp ) {
        return -1;
    }
    while ( fgets( buf, STRMAX, fp )) {
        /* XXX - Unpick 'buf' to extract the individual field values
                 (or at least the index values for this row) ... */
        row = subsTrcTable_createEntry(table
                         , subsTrcIdType
                         , subsTrcIdName
                         , subsTrcIdName_len
                        );
        if (row == NULL)
            continue;
        this = (struct subsTrcTable_entry *)row->entry;
        /* XXX - ... and then populate the 'this' data structure with
                 column values (typically) extracted from 'buf' above */
    }
    fclose(fp);
    return 0;  /* OK */
}

void
subsTrcTable_free( netsnmp_cache *cache, void *vmagic ) {
    netsnmp_tdata     *table = (netsnmp_tdata *)vmagic;
    netsnmp_tdata_row *this;

    while ((this = netsnmp_tdata_get_first_row(table))) {
        netsnmp_tdata_remove_and_delete_row(table, this);
    }
}

/** handles requests for the subsTrcTable table */
int
subsTrcTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    netsnmp_tdata              *table_data;
    netsnmp_tdata_row          *table_row;
    struct subsTrcTable_entry          *table_entry;
    int                         ret;

    DEBUGMSGTL(("subsTrcTable:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;

            table_entry = (struct subsTrcTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_SUBSTRCLEVEL:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->subsTrcLevel);
                break;
            case COLUMN_SUBSTRCTYPE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->subsTrcType);
                break;
            case COLUMN_SUBSTRCROWSTATUS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->subsTrcRowStatus);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;

            table_entry = (struct subsTrcTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_SUBSTRCLEVEL:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_SUBSTRCTYPE:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_SUBSTRCROWSTATUS:
                ret = netsnmp_check_vb_rowstatus(request->requestvb,
                         (table_entry ? RS_ACTIVE : RS_NONEXISTENT ));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error( reqinfo, request,
                                           SNMP_ERR_NOTWRITABLE );
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;

            table_entry = (struct subsTrcTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_SUBSTRCLEVEL:
                table_entry->old_subsTrcLevel = table_entry->subsTrcLevel;
                table_entry->subsTrcLevel     = *request->requestvb->val.integer;
                break;
            case COLUMN_SUBSTRCTYPE:
                table_entry->old_subsTrcType = table_entry->subsTrcType;
                table_entry->subsTrcType     = *request->requestvb->val.integer;
                break;
            }
        }
        /* Check the internal consistency of an active row */
        for (request=requests; request; request=request->next) {
            table_entry = (struct subsTrcTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_SUBSTRCROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_ACTIVE:
                case RS_CREATEANDGO:
                    if (/* XXX */) {
                        netsnmp_set_request_error( reqinfo, request,
                                                   SNMP_ERR_INCONSISTENTVALUE );
                        return SNMP_ERR_NOERROR;
                    }
                }
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;

            table_entry = (struct subsTrcTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_row   =     netsnmp_tdata_extract_row(  request);
            table_data  =     netsnmp_tdata_extract_table(request);
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_SUBSTRCLEVEL:
                table_entry->subsTrcLevel     = table_entry->old_subsTrcLevel;
                table_entry->old_subsTrcLevel = 0;
                break;
            case COLUMN_SUBSTRCTYPE:
                table_entry->subsTrcType     = table_entry->old_subsTrcType;
                table_entry->old_subsTrcType = 0;
                break;
            case COLUMN_SUBSTRCROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    if (table_entry && !table_entry->valid) {
                        subsTrcTable_removeEntry(table_data, table_row );
                    }
                }
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}
